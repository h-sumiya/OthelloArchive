pub const TESTDATA:[f32; 617] = include_data!(2468, "쥿瀭渤񂡆Ｋ񁊁ﹰ륊澈贱瀣晾ﶃ썶ﺶﺬ鮵ﴕ赥湅䜣浉澮澾澠粩ﲈ񂹲浩썕ﶇ洼䓙￷ꔳ洐脥澵嵸﹩켃泒妪浥񀦙ﺖ贠澆񁒻ﻐ㾹ﻍ񀙳澦񂣝ﺳ峳灧񁯽澺񂅝澓闚ﾙ攷溅񀯮灟񁹪ﶉ񂘗［僚ﹳ﶐龅ﾖ뗆ﾲ񀧊ﻜ񀨉ｸ䜏欼鋪ｖ렼ﳥꆡ澰񀒉泠䑕︇䊇湼겥ａﺔ爬洩瓮渑䎔濫だﺋ咚濪ꍅﺧ񂒙ﹳ漷񀆬滂詩澆魯潴䟿澂솹溯񁊁﹐񂢜ﴁﻊ㞆︋犱񀀞񁅰漗楨溷挐ﶽ䁝漄񀃓񂅬演쵆ﶭ쳺ﰬ񀬫漙끁潂ꟓ﹜ﵻﴌ辈Ｙ䔕瀈񁬄漚慗湧舝祿빜澗渁氝ꭄﺭ﹘麞￫緃ￒ񀃸ﴪ䘩ﺍ񂌁沶ꝇ澂阹濡񂅐ﴓ嶠濍䴷漤遝澟綩漾񂸴濙뜕漱衖濦䱖漝񂐗ﰐ񃘘滅ꭟ＃ꑘﻡ񀩜ﾢﾻ澒竔漱滙袿潶眤ﻸ伵漕潳瘉漽뭭潰羠ﺚ񂄲潆螖ﺆ񀐜ｱ밈渮１娣０墍潹憿潮񂀎漲䟵潿񂌛︦砖漌묻񀀍謫渲񀀕񃐢滍񁕺ﺢ񃥘湪鮭渲񃟈ﾺ뜳漧鄺￳ﰇ湃橾溾񀸥漆㪀澂賯滎㸖澀见渎颇溂戙渔愢ﴁ雫漫䈝񀀭溙뎴ﻛ先澻荠ﹼ㭹滌񁺬渓竈ﾪ煸潤񀴼／꬜ﺼ潊﹚񂅹ﴂ봩Ｂ䨳ﲾ꘢︫䴵洒ꟽﾽ曗滞澝䏍ﶩ潫袐񀇂캔漶蔐ｨ귁ﷷ뻆澞卒浊됒ﷅ堸漱񁂉ｇ鴌浶񁥣满藊滐ꌷ澬䧶澫쥰洞暹溢㟍ﾂ蟅ﾂ괰涫潘巁񀀊丕漣񁱆渹﹬񁔲ￅ񂝋濂㝭溂涓ｽ㠜滢溺潡񀊿濞񁁨溘￮㴧濡ꓐ滥颊澿鬱񀁨䪊澝뎁渏񂇈澐񁉂ﾌ䪶溗䖀澄軂ｪ櫎漋鶇潇ひ瀍徉６潛ﰚ潭䜠３񃪸񀅎毀：ꑁﳅﳁ񀀃䭓񀂪ﵫ涐띗渚嵇︐񃲖ﻻ鏎ﾯ셌񀀖觀ﾢ㼪ﻫ䗕ﵷ񀂇񀃏񀪇渚񀏦ﶇ񀎺ﵓ쾁ﲔ袠流延񀂨匴渀恥渭辊溺񃣟ｙ񂥨漡泺㶒ﳳ㚹溰䥼烣񁻵񀂆暴涧Ｗ汮葺ﾙ젙񀀃攪涀涖嘜ﴡ삎ﻵ䖱񀀄񃘶澧񂗰涬񁅆溂隈񀁗뵘渣񁺪渤뮕榾糠瀠促沃䶘瀋񂴇漞񀫬ﶽ㛭ﻳ晻ￅ外񀁜꧔溌쥝ﺆ䰐﷘񁘃ﾱ峣灋񃍭洣񀺔ﶢ䴱ﴋ椺￰ﴇ瀘񃨝﹙漶ﺣ釁澚慥炗秋灋񃷣漽㌫滊䵩񀀚瀯㝌漈쩿ﶟ񃉽ﺚ８񀀴ａﺃ冤ﶅ蠷涳坶灙貍ﷰ湿渆羂ﻬ擌渎뭕﷍񁿾񀂸꫙濼撪ﾝ껌７ﶗ끘灠沐񂥼ﴒﵱﴢ臐滀厦漓ら漞褳滳񃆫添ㆭﺐ񃑌望믵滍񁏉﹎񀊺潵񀛣񀀢񃥾ﶫﺉ澆嬳渚ꐍ淦ꓵ濒﷠䰙瀄ﳡ񂼚；貲溝񂙍﹏񂲝潶涕񃅢滌񃝥潤ꈵ潕ꯋ澴髝񀁍񃿙泮䕿湴񂿳񀀦叹滅垝ﶂ񂀞浻㮍漁牢漫񀲊漼箠ﴏ찀漛灣ﹾ쒞ﾕ񀚧񀀲ꊔ湄緯ｐ其潉꺗澞䏀澵厤漊񃨋񀀑䜟ﾗ뎣ﺾ滺꘯﵌鑳漇麍潣澺敄潒ﴂ洵潉垂񀁈ﬗ毷以Ｗ񁙌溜񃭼｢狌煮񂡅澠즫澅꒡ﻹ륖湵񀏸︩끯溛싕ﺃ񀃰溌ꛤ澍괁湄渪㪱湾轵ￏ붫洍㯣９䚊澢゜ﹽ꤭澱熴漄񀂑﹞澠聛溟㐪洣曢ﾑ컙ﻖ扢ﺯꃞﻯｻ靏﹠왧澝狜洫몈潑轗ﾢ񃥁ﴱ旒ﻥ码溆񃞄ﹽ񀀘숡漄똞渁愓涢񁮡澒뒚漀案澱뎜濌形潀囫﹈뗐濖񀥥潪񁀫滕䗀潋潔񃼟ﾴ渝濘񀓈澁澰񂢝ﾒ러ﾼ潳뾨ｙ烌ﻝ龜ｎ觛ﻘ񀬄񀂆ﾫﺬ｟滴贊湶񂝍ﾍ񀕝ￗ淬񀁭괞Ｗ񀥿漄񂜙滦溗啟ｈ񂯲񀀄񂇡湿䜘ﺑ쏱灂񃑟瀃쒸溛䀍ﺱ듁ﺨ漂񀛮潽񃤰濼ｨ漀溶쎎񀀉徴ｑ䥽湀蘖泦솗漇㧕︕뽤濱똛漀鬑潀񀋡１儼満񁣕澆颱瀵񀆔瀙諫񀀂졸ﾉ񁶬￙컧：鋺溻񃑪︯渁潕񀀦鴥滭肰渢忢ﷃ年︀񂴦澘玲澿靍滭񂹻￱䄺ﾫ淩￩뽆澷񂞀漿浃湿泘ﺫ普Ｃ㎵ﾘ񂽌滗騝潂淀＂񀗶潹񀄮ﺟ񃹼ﺖ벓漃񂅳溱񂒺Ｙ񀈚漷ꕾ漌쪡漸ﻫ㐇湚񂠧ﾭ瘁澮蒼渗꼞浊񂲞溁頞漨񃭄渁鮎񀀎䨵涵񀣸湄񂊖ￒ񂜒淌񁖛濋񀇖滿垥澝񃃷＼꜎漠籥漝﷊澁ﾃ񂈻溳񃀅񀀑秼︗㫅潠앢﷈ﻗ紙񀀑輠溏񃝵澊둤滄쩄滱喺ｱ񁗖񀁒윂ﻙꨁ澫񂍶Ｕ昪ﴸꍿｂ聾湪񂅸澪鏔（瞾溅庪漽筎潇剅Ｑ雍￩䯖漛蟹￭颕漊밫滖刺︟񁸄񀀾䰹潓꣄滞񃜛｜溏紀滌䫂澳뭣潀珳ﹾ鶕氺付澮񀒱潥矼潦놭澩蔟濉񀢡漠񀪼涽㊾漝񀐫ﺯ躂滐񂹇／㦎ｰ䲾ｎ찾ﻝ񃝴澟琥溘");

use std::arch::x86_64::*; //python:del
use std::mem::transmute; //python:del
use std::ops;

const fn pattern_table_sub(p: u32) -> f32 {
    match p {
        0 => 0f32,
        1 => 1f32,
        2 => -1f32,
        _ => 0f32,
    }
}

const fn pattern_table(p: [u32; 10]) -> T10 {
    let mut i = 0;
    let mut buf = [0f32; 8];
    while i < 8 {
        buf[i] = pattern_table_sub(p[i]);
        i += 1;
    }
    T10 {
        0: T8::new([
            buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
        ]),
        1: pattern_table_sub(p[8]),
        2: pattern_table_sub(p[9]),
    }
}

const fn pattern() -> [T10; 59049] {
    let mut table: [T10; 59049] = unsafe { transmute([[0f32; 16]; 59049]) };
    let mut now = [0u32; 10];
    let mut next = 0;
    let mut val = 0;
    let mut i = 0;
    while i < 59049 {
        table[i] = pattern_table(now);
        if val < 2 {
            val += 1;
            now[next] = val;
        } else {
            next += 1;
            let mut j = 0;
            while j < next {
                now[j] = 0;
                j += 1;
            }
            while next < 9 && now[next] == 2 {
                now[next] = 0;
                next += 1;
            }
            now[next] += 1;
            next = 0;
            val = 0;
        }
        i += 1;
    }
    table
}

const PATTERN_TABLE: [T10; 59049] = pattern();

const RELU: __m256 = unsafe { transmute([0f32; 8]) };

#[derive(Clone, Copy, Debug)]
struct T8(__m256);
#[derive(Clone, Copy, Debug)]
struct T10(T8, f32, f32);

impl T8 {
    const fn new(data: [f32; 8]) -> Self {
        unsafe { T8(transmute(data)) }
    }
    fn sum(&self) -> f32 {
        unsafe {
            let v: [f32; 8] = transmute(self.0);
            let mut sum = 0f32;
            for i in 0..8 {
                sum += v.get_unchecked(i);
            }
            sum
        }
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn relu(&self) -> Self {
        unsafe { T8(_mm256_max_ps(self.0, RELU)) }
    }
}

#[inline]
#[target_feature(enable = "avx2")]
unsafe fn _add(a: __m256, b: __m256) -> __m256 {
    unsafe { _mm256_add_ps(a, b) }
}

#[inline]
#[target_feature(enable = "avx2")]
unsafe fn _mul(a: __m256, b: __m256) -> __m256 {
    unsafe { _mm256_mul_ps(a, b) }
}

impl ops::Add<T8> for T8 {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        unsafe { T8(_add(self.0, rhs.0)) }
    }
}

impl ops::Mul<T8> for T8 {
    type Output = Self;
    #[inline]
    fn mul(self, rhs: Self) -> Self {
        unsafe { T8(_mul(self.0, rhs.0)) }
    }
}

#[inline]
#[target_feature(enable = "avx2")]
unsafe fn _mul_f32(a: __m256, b: f32) -> __m256 {
    unsafe { _mm256_mul_ps(a, _mm256_set1_ps(b)) }
}

impl ops::Mul<f32> for T8 {
    type Output = Self;
    #[inline]
    fn mul(self, rhs: f32) -> Self {
        unsafe { T8(_mul_f32(self.0, rhs)) }
    }
}

struct Linear10 {
    w: [T8; 10],
    w1: [T8; 2],
    w2: [f32; 4],
    b: T8,
    b1: f32,
    b2: f32,
}

impl Linear10 {
    fn load(data: &[f32]) -> Self {
        let mut w = [T8::new([0f32; 8]); 10];
        let mut w1 = [[0f32; 8]; 2];
        let mut offset = 0;
        for i in 0..10 {
            w[i] = unsafe {
                let mut buf = [0f32; 8];
                buf.copy_from_slice(&data[offset..offset + 8]);
                transmute(buf)
            };
            offset += 10;
        }
        offset = 0;
        for i in 0..8 {
            w1[0][i] = data[offset + 8];
            w1[1][i] = data[offset + 9];
            offset += 10;
        }
        let w2 = [data[88], data[89], data[98], data[99]];
        let b: T8 = unsafe {
            let mut buf = [0f32; 8];
            buf.copy_from_slice(&data[100..108]);
            transmute(buf)
        };
        let b1 = data[108];
        let b2 = data[109];
        Self {
            w,
            w1: unsafe { transmute(w1) },
            w2,
            b,
            b1,
            b2,
        }
    }

    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, input: &T10) -> T10 {
        unsafe {
            let mut output = [0f32; 8];
            for i in 0..8 {
                *output.get_unchecked_mut(i) = (*self.w.get_unchecked(i) * input.0).sum();
            }
            let output = (transmute::<_, T8>(output)
                + *self.w1.get_unchecked(0) * input.1
                + *self.w1.get_unchecked(1) * input.2
                + self.b)
                .relu();
            let mut out1 = (*self.w.get_unchecked(8) * input.0).sum()
                + *self.w2.get_unchecked(0) * input.1
                + *self.w2.get_unchecked(1) * input.2
                + self.b1;
            if out1 < 0f32 {
                out1 = 0f32;
            }
            let mut out2 = (*self.w.get_unchecked(9) * input.0).sum()
                + *self.w2.get_unchecked(2) * input.1
                + *self.w2.get_unchecked(3) * input.2
                + self.b2;
            if out2 < 0f32 {
                out2 = 0f32;
            }
            T10(output, out1, out2)
        }
    }
}

struct Model10 {
    l1: Linear10,
    l2: Linear10,
    w: (T8, f32, f32),
    b: f32,
}

impl Model10 {
    fn load(data: &[f32]) -> Self {
        Self {
            l1: Linear10::load(&data[0..110]),
            l2: Linear10::load(&data[110..220]),
            w: unsafe {
                let mut buf = [0f32; 8];
                buf.copy_from_slice(&data[220..228]);
                (transmute(buf), data[228], data[229])
            },
            b: data[230],
        }
    }

    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, input: &T10) -> f32 {
        unsafe {
            let output = self.l1.calc(input);
            let output = self.l2.calc(&output);
            (output.0 * self.w.0).sum() + (output.1 * self.w.1) + (output.2 * self.w.2) + self.b
        }
    }
}

struct Linear8 {
    w: [T8; 8],
    b: T8,
}

impl Linear8 {
    fn new(data: &[f32]) -> Self {
        let mut buf: [f32; 64] = [0f32; 64];
        buf.copy_from_slice(&data[0..64]);
        let w = unsafe { transmute(buf) };
        let mut buf: [f32; 8] = [0f32; 8];
        buf.copy_from_slice(&data[64..72]);
        let b = unsafe { transmute(buf) };
        Self { w, b }
    }

    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, data: &T8) -> T8 {
        let mut output = [0f32; 8];
        unsafe {
            for i in 0..8 {
                *output.get_unchecked_mut(i) = (*self.w.get_unchecked(i) * *data).sum();
            }
            (transmute::<_, T8>(output) + self.b).relu()
        }
    }
}

struct Model8 {
    l1: Linear8,
    l2: Linear8,
    w: T8,
    b: f32,
}

impl Model8 {
    fn load(data: &[f32]) -> Self {
        Self {
            l1: Linear8::new(&data[0..72]),
            l2: Linear8::new(&data[72..144]),
            w: unsafe {
                let mut buf = [0f32; 8];
                buf.copy_from_slice(&data[144..152]);
                transmute(buf)
            },
            b: data[152],
        }
    }

    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, data: &T8) -> f32 {
        let output = self.l1.calc(data);
        let output = self.l2.calc(&output);
        (output * self.w).sum() + self.b
    }
}

pub struct Score {
    edge: Vec<f32>,
    corner: Vec<f32>,
    cross: Vec<f32>,
    cn_w: f32,
    cn_b: f32,
}

impl Score {
    fn load(data: &[f32]) -> Self {
        let edge_model = Model10::load(&data);
        let corner_model = Model10::load(&data[231..]);
        let cross_model = Model8::load(&data[462..]);
        unsafe {
            let mut edge = Vec::with_capacity(59049);
            let mut corner = Vec::with_capacity(59049);
            let mut cross = Vec::with_capacity(6561);
            edge.set_len(59049);
            corner.set_len(59049);
            cross.set_len(6561);
            for i in 0..59049 {
                *edge.get_unchecked_mut(i) = edge_model.calc(&PATTERN_TABLE[i]);
            }
            for i in 0..59049 {
                *corner.get_unchecked_mut(i) = corner_model.calc(&PATTERN_TABLE[i]);
            }
            for i in 0..6561 {
                *cross.get_unchecked_mut(i) = cross_model.calc(&PATTERN_TABLE[i].0);
            }
            Self {
                edge,
                corner,
                cross,
                cn_w: data[615],
                cn_b: data[616],
            }
        }
    }
    pub unsafe fn calc(&self, index: Index, cn: usize) -> f32 {
        let indexes = index.indexes();
        let mut score = 0f32;
        for i in 0..4 {
            score += self.edge.get_unchecked(indexes[i]);
        }
        for i in 4..8 {
            score += self.corner.get_unchecked(indexes[i]);
        }
        for i in 8..10 {
            score += self.cross.get_unchecked(indexes[i]);
        }
        score += cn as f32 * self.cn_w + self.cn_b;
        score
    }
}

#[derive(Clone, Copy, Debug)]
pub struct Index(__m256i);
impl Index {
    const fn from_index(data: &[u16; 10]) -> Self {
        unsafe {
            transmute([
                data[8], data[0], data[1], data[2], data[9], data[3], data[4], data[5], 0, data[6],
                data[7], 0, 0, 0, 0, 0,
            ])
        }
    }
    fn indexes(&self) -> [usize; 10] {
        unsafe {
            let v: [u16; 16] = transmute(self.0);
            let mut buf = [0usize; 10];
            *buf.get_unchecked_mut(0) = *v.get_unchecked(1) as usize;
            *buf.get_unchecked_mut(1) = *v.get_unchecked(2) as usize;
            *buf.get_unchecked_mut(2) = *v.get_unchecked(3) as usize;
            *buf.get_unchecked_mut(3) = *v.get_unchecked(5) as usize;
            *buf.get_unchecked_mut(4) = *v.get_unchecked(6) as usize;
            *buf.get_unchecked_mut(5) = *v.get_unchecked(7) as usize;
            *buf.get_unchecked_mut(6) = *v.get_unchecked(9) as usize;
            *buf.get_unchecked_mut(7) = *v.get_unchecked(10) as usize;
            *buf.get_unchecked_mut(8) = *v.get_unchecked(0) as usize;
            *buf.get_unchecked_mut(9) = *v.get_unchecked(4) as usize;
            buf
        }
    }
    const fn add(mut d1: [u16; 10], d2: &[u16; 10]) -> [u16; 10] {
        let mut i = 0;
        while i < 10 {
            d1[i] += d2[i];
            i += 1;
        }
        d1
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    pub unsafe fn x2(&self) -> Self {
        unsafe { Index(_mm256_slli_epi16(self.0, 1)) }
    }
}

#[inline]
#[target_feature(enable = "avx2")]
unsafe fn add_index(a: __m256i, b: __m256i) -> __m256i {
    unsafe { _mm256_add_epi16(a, b) }
}

impl ops::Add<Index> for Index {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        unsafe { Index(add_index(self.0, rhs.0)) }
    }
}

impl ops::AddAssign<Index> for Index {
    #[inline]
    fn add_assign(&mut self, rhs: Self) {
        unsafe {
            self.0 = add_index(self.0, rhs.0);
        }
    }
}

impl std::fmt::Display for Index {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let indexes = self.indexes();
        write!(f, "[")?;
        for i in 0..10 {
            write!(f, "{},", indexes[i])?;
        }
        write!(f, "]")
    }
}

const INDEXES:[[[u16;10];8];8] = include_data!(1280, "、　　ン、　　　、　　　　　〃　　　　　〃　　　〉　　　　　〉　　　〛　　　　　〛　　　　糣　　　　け　　　　㢋　　　　　　　　　け　　　　ン、　　　、　　　㢋　　　　け　　　　　　　　　ン　　　〃　㋙　　　㋙　　　　　㢋　　　　　　　　　䦡　　　　　　　　　糣　　　　䦡　　　　　　　　　ン　　　㋙　　　　　〃　　　　　　　け㢋　　　　　　　　糣䦡　　　　　　　　　　　　　〉　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　ン　㋙　　　㋙　　　　　〃　　　〉　　　　　　　〛糣　　　　　　　　䦡　　　　　　　　　　　　　　　　　　　　　　　　〛　　　　　　　　　　け　　　　　　　　　　　㢋　　　　　　　　　〉　　　〛　　　　　　　〉　　　〛　　　　　㢋　　　　　　　　　　　　　　　　　　　　　　　　　〛　　　　　　　　け　　　　　　　　　　　　䦡　　　　　　　　　〛　　　　糣　　　　　　〃　　　〉　　　　　㋙　　　㋙　　　　　　　　　　　〉　　　　　　　　　　　　　　　　　　　　　　　　　　　　ン　　糣　　　　䦡　　　　け　　　　㢋　　　　　　　　　　〃　　　　　　　　　ン　〃　　糣　　　　䦡　　　　䦡　　　　　　　　　㢋　　　　　　　　　㋙　　　㋙　　　　　　　　　ン　㋙　　　　　　　け　　　　　ン、　　　、　、　　　　　　　け　　　　け　　　　㢋　　　　〛　　　　糣　　　　〉　　　〛　　　　　〃　　　〉　　　　　　　　　〃　　　　ン、　　　、　㢋　");

const fn index_table() -> [[Index; 256]; 8] {
    let bits = [1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7];
    unsafe {
        let mut table: [[Index; 256]; 8] = transmute([0u8; 65536]);
        let mut i = 0;
        while i < 8 {
            let mut j = 0;
            let line_index = INDEXES[i];
            let mut line: [Index; 256] = transmute([0u8; 8192]);
            while j < 256 {
                let mut index = [0u16; 10];
                let mut k = 0;
                while k < 8 {
                    if bits[k] & j != 0 {
                        index = Index::add(index, &line_index[k]);
                    }
                    k += 1;
                }
                line[j] = Index::from_index(&index);
                j += 1;
            }
            table[i] = line;
            i += 1;
        }
        table
    }
}
const INDEX_TABLE: [[Index; 256]; 8] = index_table();

pub fn temp() {
    println!("=====score3=====");
    let score = Score::load(&TESTDATA);
    println!("{}", score.cn_w);
    println!("{}", score.cn_b);
    println!("edge:{}", score.edge[0]);
    println!("{}", score.edge[59048]);
    println!("corner:{}", score.corner[0]);
    println!("{}", score.corner[59048]);
    println!("cross{}", score.cross[0]);
    println!("{}", score.cross[6560]);

    unsafe {
        let i1 = INDEX_TABLE[0][1];
        println!("{}", i1);
        let i2 = i1.x2();
        println!("{}", i2);
        let i3 = i2 + i1;
        println!("{}", i3);
    }
}
