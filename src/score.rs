const TESTDATA:[u32; 617] = include_data!(2468, "쥿瀭渤񂡆Ｋ񁊁ﹰ륊澈贱瀣晾ﶃ썶ﺶﺬ鮵ﴕ赥湅䜣浉澮澾澠粩ﲈ񂹲浩썕ﶇ洼䓙￷ꔳ洐脥澵嵸﹩켃泒妪浥񀦙ﺖ贠澆񁒻ﻐ㾹ﻍ񀙳澦񂣝ﺳ峳灧񁯽澺񂅝澓闚ﾙ攷溅񀯮灟񁹪ﶉ񂘗［僚ﹳ﶐龅ﾖ뗆ﾲ񀧊ﻜ񀨉ｸ䜏欼鋪ｖ렼ﳥꆡ澰񀒉泠䑕︇䊇湼겥ａﺔ爬洩瓮渑䎔濫だﺋ咚濪ꍅﺧ񂒙ﹳ漷񀆬滂詩澆魯潴䟿澂솹溯񁊁﹐񂢜ﴁﻊ㞆︋犱񀀞񁅰漗楨溷挐ﶽ䁝漄񀃓񂅬演쵆ﶭ쳺ﰬ񀬫漙끁潂ꟓ﹜ﵻﴌ辈Ｙ䔕瀈񁬄漚慗湧舝祿빜澗渁氝ꭄﺭ﹘麞￫緃ￒ񀃸ﴪ䘩ﺍ񂌁沶ꝇ澂阹濡񂅐ﴓ嶠濍䴷漤遝澟綩漾񂸴濙뜕漱衖濦䱖漝񂐗ﰐ񃘘滅ꭟ＃ꑘﻡ񀩜ﾢﾻ澒竔漱滙袿潶眤ﻸ伵漕潳瘉漽뭭潰羠ﺚ񂄲潆螖ﺆ񀐜ｱ밈渮１娣０墍潹憿潮񂀎漲䟵潿񂌛︦砖漌묻񀀍謫渲񀀕񃐢滍񁕺ﺢ񃥘湪鮭渲񃟈ﾺ뜳漧鄺￳ﰇ湃橾溾񀸥漆㪀澂賯滎㸖澀见渎颇溂戙渔愢ﴁ雫漫䈝񀀭溙뎴ﻛ先澻荠ﹼ㭹滌񁺬渓竈ﾪ煸潤񀴼／꬜ﺼ潊﹚񂅹ﴂ봩Ｂ䨳ﲾ꘢︫䴵洒ꟽﾽ曗滞澝䏍ﶩ潫袐񀇂캔漶蔐ｨ귁ﷷ뻆澞卒浊됒ﷅ堸漱񁂉ｇ鴌浶񁥣满藊滐ꌷ澬䧶澫쥰洞暹溢㟍ﾂ蟅ﾂ괰涫潘巁񀀊丕漣񁱆渹﹬񁔲ￅ񂝋濂㝭溂涓ｽ㠜滢溺潡񀊿濞񁁨溘￮㴧濡ꓐ滥颊澿鬱񀁨䪊澝뎁渏񂇈澐񁉂ﾌ䪶溗䖀澄軂ｪ櫎漋鶇潇ひ瀍徉６潛ﰚ潭䜠３񃪸񀅎毀：ꑁﳅﳁ񀀃䭓񀂪ﵫ涐띗渚嵇︐񃲖ﻻ鏎ﾯ셌񀀖觀ﾢ㼪ﻫ䗕ﵷ񀂇񀃏񀪇渚񀏦ﶇ񀎺ﵓ쾁ﲔ袠流延񀂨匴渀恥渭辊溺񃣟ｙ񂥨漡泺㶒ﳳ㚹溰䥼烣񁻵񀂆暴涧Ｗ汮葺ﾙ젙񀀃攪涀涖嘜ﴡ삎ﻵ䖱񀀄񃘶澧񂗰涬񁅆溂隈񀁗뵘渣񁺪渤뮕榾糠瀠促沃䶘瀋񂴇漞񀫬ﶽ㛭ﻳ晻ￅ外񀁜꧔溌쥝ﺆ䰐﷘񁘃ﾱ峣灋񃍭洣񀺔ﶢ䴱ﴋ椺￰ﴇ瀘񃨝﹙漶ﺣ釁澚慥炗秋灋񃷣漽㌫滊䵩񀀚瀯㝌漈쩿ﶟ񃉽ﺚ８񀀴ａﺃ冤ﶅ蠷涳坶灙貍ﷰ湿渆羂ﻬ擌渎뭕﷍񁿾񀂸꫙濼撪ﾝ껌７ﶗ끘灠沐񂥼ﴒﵱﴢ臐滀厦漓ら漞褳滳񃆫添ㆭﺐ񃑌望믵滍񁏉﹎񀊺潵񀛣񀀢񃥾ﶫﺉ澆嬳渚ꐍ淦ꓵ濒﷠䰙瀄ﳡ񂼚；貲溝񂙍﹏񂲝潶涕񃅢滌񃝥潤ꈵ潕ꯋ澴髝񀁍񃿙泮䕿湴񂿳񀀦叹滅垝ﶂ񂀞浻㮍漁牢漫񀲊漼箠ﴏ찀漛灣ﹾ쒞ﾕ񀚧񀀲ꊔ湄緯ｐ其潉꺗澞䏀澵厤漊񃨋񀀑䜟ﾗ뎣ﺾ滺꘯﵌鑳漇麍潣澺敄潒ﴂ洵潉垂񀁈ﬗ毷以Ｗ񁙌溜񃭼｢狌煮񂡅澠즫澅꒡ﻹ륖湵񀏸︩끯溛싕ﺃ񀃰溌ꛤ澍괁湄渪㪱湾轵ￏ붫洍㯣９䚊澢゜ﹽ꤭澱熴漄񀂑﹞澠聛溟㐪洣曢ﾑ컙ﻖ扢ﺯꃞﻯｻ靏﹠왧澝狜洫몈潑轗ﾢ񃥁ﴱ旒ﻥ码溆񃞄ﹽ񀀘숡漄똞渁愓涢񁮡澒뒚漀案澱뎜濌形潀囫﹈뗐濖񀥥潪񁀫滕䗀潋潔񃼟ﾴ渝濘񀓈澁澰񂢝ﾒ러ﾼ潳뾨ｙ烌ﻝ龜ｎ觛ﻘ񀬄񀂆ﾫﺬ｟滴贊湶񂝍ﾍ񀕝ￗ淬񀁭괞Ｗ񀥿漄񂜙滦溗啟ｈ񂯲񀀄񂇡湿䜘ﺑ쏱灂񃑟瀃쒸溛䀍ﺱ듁ﺨ漂񀛮潽񃤰濼ｨ漀溶쎎񀀉徴ｑ䥽湀蘖泦솗漇㧕︕뽤濱똛漀鬑潀񀋡１儼満񁣕澆颱瀵񀆔瀙諫񀀂졸ﾉ񁶬￙컧：鋺溻񃑪︯渁潕񀀦鴥滭肰渢忢ﷃ年︀񂴦澘玲澿靍滭񂹻￱䄺ﾫ淩￩뽆澷񂞀漿浃湿泘ﺫ普Ｃ㎵ﾘ񂽌滗騝潂淀＂񀗶潹񀄮ﺟ񃹼ﺖ벓漃񂅳溱񂒺Ｙ񀈚漷ꕾ漌쪡漸ﻫ㐇湚񂠧ﾭ瘁澮蒼渗꼞浊񂲞溁頞漨񃭄渁鮎񀀎䨵涵񀣸湄񂊖ￒ񂜒淌񁖛濋񀇖滿垥澝񃃷＼꜎漠籥漝﷊澁ﾃ񂈻溳񃀅񀀑秼︗㫅潠앢﷈ﻗ紙񀀑輠溏񃝵澊둤滄쩄滱喺ｱ񁗖񀁒윂ﻙꨁ澫񂍶Ｕ昪ﴸꍿｂ聾湪񂅸澪鏔（瞾溅庪漽筎潇剅Ｑ雍￩䯖漛蟹￭颕漊밫滖刺︟񁸄񀀾䰹潓꣄滞񃜛｜溏紀滌䫂澳뭣潀珳ﹾ鶕氺付澮񀒱潥矼潦놭澩蔟濉񀢡漠񀪼涽㊾漝񀐫ﺯ躂滐񂹇／㦎ｰ䲾ｎ찾ﻝ񃝴澟琥溘");

const fn add_f32(x: u32, y: u32) -> u32 {
    const fn cs(x: u32) -> i32 {
        if x & 0x80000000 == 0 {
            1
        } else {
            -1
        }
    }
    if x == 0 {
        return y;
    } else if y == 0 {
        return x;
    }
    let ex = ((x >> 23) & 0xFF) as i32 - 127;
    let ey = ((y >> 23) & 0xFF) as i32 - 127;
    let (x, y, ex, ey) = if ex > ey {
        (x, y, ex, ey)
    } else {
        (y, x, ey, ex)
    };
    let fx = ((x & 0x007FFFFF) | 0x00800000) as i32 * cs(x);
    let fy = (((y & 0x007FFFFF) | 0x00800000) >> (ex - ey)) as i32 * cs(y);
    let (f, s) = if fx + fy < 0 {
        ((-(fx + fy)) as u32, 0x80000000 as u32)
    } else {
        ((fx + fy) as u32, 0)
    };
    let mut e = ex + 127;
    let shift = 8 - f.leading_zeros() as i32;
    let f = if shift < 0 { f << -shift } else { f >> shift } & 0x007FFFFF;
    e += shift;
    if e < 0 {
        e = 0;
    }
    s | ((e as u32) << 23) | f
}

const fn mult_f32(x: u32, y: u32) -> u32 {
    if x == 0 || y == 0 {
        return 0;
    }
    let s = x & 0x80000000 ^ y & 0x80000000;
    let ex = ((x >> 23) & 0xFF) as i32 - 127;
    let ey = ((y >> 23) & 0xFF) as i32 - 127;
    let mut e = ex + ey + 127;
    let fx = ((x & 0x007FFFFF) | 0x00800000) as u64;
    let fy = ((y & 0x007FFFFF) | 0x00800000) as u64;
    let f = fx * fy;
    let shift = 17 - f.leading_zeros() as i32;
    let f = ((f >> (shift + 23)) & 0x007FFFFF) as u32;
    e += shift;
    if e < 0 {
        e = 0;
    }
    s | ((e as u32) << 23) | f
}

const fn read_u32(data: &[u8], offset: usize) -> u32 {
    let mut res = 0;
    let mut i = 0;
    while i < 4 {
        res |= (data[offset + i] as u32) << (i * 8);
        i += 1;
    }
    res
}

macro_rules! model {
    ($name:ident,$input:expr,$output:expr) => {
        struct $name {
            net: [[u32; $input]; $output],
            bias: [u32; $output],
        }
        impl $name {
            const fn size() -> usize {
                $input * $output + $output
            }
            const fn load(data: &[u32], start: usize) -> Self {
                let mut net = [[0; $input]; $output];
                let mut bias = [0; $output];
                let mut slice = [0; $input * $output + $output];
                let mut i = 0;
                while i < $output {
                    let mut j = 0;
                    while j < $input {
                        net[i][j] = data[i * $input + j + start];
                        j += 1;
                    }
                    i += 1;
                }
                i = 0;
                while i < $output {
                    bias[i] = data[i + $input * $output + start];
                    i += 1;
                }
                Self { net, bias }
            }
            const fn calc(&self, input: &[u32]) -> [u32; $output] {
                let mut output = [0; $output];
                let mut i = 0;
                while i < $output {
                    let mut sum = 0;
                    let mut j = 0;
                    while j < $input {
                        sum = add_f32(sum, mult_f32(input[j], self.net[i][j]));
                        j += 1;
                    }
                    output[i] = add_f32(sum, self.bias[i]);
                    i += 1;
                }
                output
            }
        }
    };
}

macro_rules! models {
    ($name:ident, $($n:ident,$model:ty),* ) => {
        struct $name {
            $(
                $n: $model,
            )*
        }
        impl $name {
            const fn size() -> usize {
                0 $(+ <$model>::size())*
            }
            const fn load(data: &[u32], start: usize) -> Self {
                let mut offset = start;
                $(
                    let $n = <$model>::load(data, offset);
                    offset += <$model>::size();
                )*
                Self {
                    $(
                        $n,
                    )*
                }
            }
            const fn calc(&self, input: &[u32]) -> u32 {
                let output = 0;
                $(
                    let mut input = self.$n.calc(&input);
                    let output = input[0];
                    let mut i = 0;
                    while i < input.len() {
                        if input[i] & 0x80000000 != 0 {
                            input[i] = 0;
                        }
                        i += 1;
                    }
                )*
                output
            }
        }
    };
}

const fn pattern_table(p: [u32; 10]) -> [u32; 10] {
    unsafe {
        let mut i = 0;
        let mut buf = [0u32; 10];
        while i < 10 {
            let h = match p[i] {
                0 => transmute(0f32),
                1 => transmute(1f32),
                2 => transmute(-1f32),
                _ => transmute(0f32),
            };
            buf[i] = h;
            i += 1;
        }
        buf
    }
}

const fn pattern() -> [[u32; 10]; 59049] {
    let mut table = [[0u32; 10]; 59049];
    let mut now = [0u32; 10];
    let mut next = 0;
    let mut val = 0;
    let mut i = 0;
    while i < 59049 {
        table[i] = now;
        if val < 2 {
            val += 1;
            now[next] = val;
        } else {
            next += 1;
            let mut j = 0;
            while j < next {
                now[j] = 0;
                j += 1;
            }
            while next < 9 && now[next] == 2 {
                now[next] = 0;
                next += 1;
            }
            now[next] += 1;
            next = 0;
            val = 0;
        }
        i += 1;
    }
    i = 0;
    while i < 59049 {
        table[i] = pattern_table(table[i]);
        i += 1;
    }
    table
}

pub const PATTERN_TABLE: [[u32; 10]; 59049] = pattern();

use std::mem::transmute; // python:del
const INDEXES:[u8; 96] = include_data!(96, "㈀㐃㜅㬊㴌䜇土漯世带洿欼栺搵戳堸䠠【儩䄙㄀㌂㤈䀊䠑㼇众㸆㔖㐍渿氽昷張圮怸倨愹権欲㤀䬒崤漶愸匪䔜㜎");

model!(MODEL_10_10, 10, 10);
model!(MODEL_10_1, 10, 1);
model!(MODEL_8_8, 8, 8);
model!(MODEL_8_1, 8, 1);
models!(EDGE_MODEL, a, MODEL_10_10, b, MODEL_10_10, c, MODEL_10_1);
models!(CORNER_MODEL, a, MODEL_10_10, b, MODEL_10_10, c, MODEL_10_1);
models!(CROSS_MODEL, a, MODEL_8_8, b, MODEL_8_8, c, MODEL_8_1);

macro_rules! calc_score {
    ($size:expr,$len:expr,$model:expr,$index:expr) => {{
        let mut table = [0u32; $size];
        let mut i = 0;
        while i < $size {
            let input = PATTERN_TABLE[i + $index];
            let output = $model.calc(&input);
            table[i] = output;
            i += 1;
        }
        table
    }};
}

macro_rules! calc_score_all {
    ($name:ident,$model:expr,$total:expr,$len:expr,$($names:ident,$index:expr,$size:expr),*) => {
        $(
            const $names: [u32; $size] = calc_score!($size, $len, $model, $index);
        )*
        const $name:[f32;$total] = unsafe {
            std::mem::transmute(
                (
                    $(
                        $names,
                    )*
                )
            )
        };
    };
}

pub fn temp() {
    //const EDGE_MODEL: EDGE_MODEL = EDGE_MODEL::load(&TESTDATA, 0);
    let EDGE1 = MODEL_10_10::load(&TESTDATA, 0);
    let EDGE2 = MODEL_10_10::load(&TESTDATA, 110);
    unsafe {
        let net: [f32; 10] = transmute(EDGE1.net[0]);
        println!("{:?}", net);
        let net: [f32; 10] = transmute(EDGE2.net[0]);
        println!("{:?}", net);

        let i: [u32; 10] = transmute([0.0f32; 10]);
        let mut o = EDGE1.calc(&i);
        o[8] = 0;
        let o2 = EDGE2.calc(&i);
        let o = transmute::<_, [f32; 10]>(o);

        let o2 = transmute::<_, [f32; 10]>(o2);
        println!("{:?}", o);
        println!("{:?}", o2);
        let EDGE = EDGE_MODEL::load(&TESTDATA, 0);
        let o = EDGE.calc(&i);
        let o = transmute::<_,f32>(o);
        println!("{:?}", o);
    }

}
