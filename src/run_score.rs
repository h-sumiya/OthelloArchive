const TESTDATA:[f32; 617] = include_data!(2468, "쥿瀭渤񂡆Ｋ񁊁ﹰ륊澈贱瀣晾ﶃ썶ﺶﺬ鮵ﴕ赥湅䜣浉澮澾澠粩ﲈ񂹲浩썕ﶇ洼䓙￷ꔳ洐脥澵嵸﹩켃泒妪浥񀦙ﺖ贠澆񁒻ﻐ㾹ﻍ񀙳澦񂣝ﺳ峳灧񁯽澺񂅝澓闚ﾙ攷溅񀯮灟񁹪ﶉ񂘗［僚ﹳ﶐龅ﾖ뗆ﾲ񀧊ﻜ񀨉ｸ䜏欼鋪ｖ렼ﳥꆡ澰񀒉泠䑕︇䊇湼겥ａﺔ爬洩瓮渑䎔濫だﺋ咚濪ꍅﺧ񂒙ﹳ漷񀆬滂詩澆魯潴䟿澂솹溯񁊁﹐񂢜ﴁﻊ㞆︋犱񀀞񁅰漗楨溷挐ﶽ䁝漄񀃓񂅬演쵆ﶭ쳺ﰬ񀬫漙끁潂ꟓ﹜ﵻﴌ辈Ｙ䔕瀈񁬄漚慗湧舝祿빜澗渁氝ꭄﺭ﹘麞￫緃ￒ񀃸ﴪ䘩ﺍ񂌁沶ꝇ澂阹濡񂅐ﴓ嶠濍䴷漤遝澟綩漾񂸴濙뜕漱衖濦䱖漝񂐗ﰐ񃘘滅ꭟ＃ꑘﻡ񀩜ﾢﾻ澒竔漱滙袿潶眤ﻸ伵漕潳瘉漽뭭潰羠ﺚ񂄲潆螖ﺆ񀐜ｱ밈渮１娣０墍潹憿潮񂀎漲䟵潿񂌛︦砖漌묻񀀍謫渲񀀕񃐢滍񁕺ﺢ񃥘湪鮭渲񃟈ﾺ뜳漧鄺￳ﰇ湃橾溾񀸥漆㪀澂賯滎㸖澀见渎颇溂戙渔愢ﴁ雫漫䈝񀀭溙뎴ﻛ先澻荠ﹼ㭹滌񁺬渓竈ﾪ煸潤񀴼／꬜ﺼ潊﹚񂅹ﴂ봩Ｂ䨳ﲾ꘢︫䴵洒ꟽﾽ曗滞澝䏍ﶩ潫袐񀇂캔漶蔐ｨ귁ﷷ뻆澞卒浊됒ﷅ堸漱񁂉ｇ鴌浶񁥣满藊滐ꌷ澬䧶澫쥰洞暹溢㟍ﾂ蟅ﾂ괰涫潘巁񀀊丕漣񁱆渹﹬񁔲ￅ񂝋濂㝭溂涓ｽ㠜滢溺潡񀊿濞񁁨溘￮㴧濡ꓐ滥颊澿鬱񀁨䪊澝뎁渏񂇈澐񁉂ﾌ䪶溗䖀澄軂ｪ櫎漋鶇潇ひ瀍徉６潛ﰚ潭䜠３񃪸񀅎毀：ꑁﳅﳁ񀀃䭓񀂪ﵫ涐띗渚嵇︐񃲖ﻻ鏎ﾯ셌񀀖觀ﾢ㼪ﻫ䗕ﵷ񀂇񀃏񀪇渚񀏦ﶇ񀎺ﵓ쾁ﲔ袠流延񀂨匴渀恥渭辊溺񃣟ｙ񂥨漡泺㶒ﳳ㚹溰䥼烣񁻵񀂆暴涧Ｗ汮葺ﾙ젙񀀃攪涀涖嘜ﴡ삎ﻵ䖱񀀄񃘶澧񂗰涬񁅆溂隈񀁗뵘渣񁺪渤뮕榾糠瀠促沃䶘瀋񂴇漞񀫬ﶽ㛭ﻳ晻ￅ外񀁜꧔溌쥝ﺆ䰐﷘񁘃ﾱ峣灋񃍭洣񀺔ﶢ䴱ﴋ椺￰ﴇ瀘񃨝﹙漶ﺣ釁澚慥炗秋灋񃷣漽㌫滊䵩񀀚瀯㝌漈쩿ﶟ񃉽ﺚ８񀀴ａﺃ冤ﶅ蠷涳坶灙貍ﷰ湿渆羂ﻬ擌渎뭕﷍񁿾񀂸꫙濼撪ﾝ껌７ﶗ끘灠沐񂥼ﴒﵱﴢ臐滀厦漓ら漞褳滳񃆫添ㆭﺐ񃑌望믵滍񁏉﹎񀊺潵񀛣񀀢񃥾ﶫﺉ澆嬳渚ꐍ淦ꓵ濒﷠䰙瀄ﳡ񂼚；貲溝񂙍﹏񂲝潶涕񃅢滌񃝥潤ꈵ潕ꯋ澴髝񀁍񃿙泮䕿湴񂿳񀀦叹滅垝ﶂ񂀞浻㮍漁牢漫񀲊漼箠ﴏ찀漛灣ﹾ쒞ﾕ񀚧񀀲ꊔ湄緯ｐ其潉꺗澞䏀澵厤漊񃨋񀀑䜟ﾗ뎣ﺾ滺꘯﵌鑳漇麍潣澺敄潒ﴂ洵潉垂񀁈ﬗ毷以Ｗ񁙌溜񃭼｢狌煮񂡅澠즫澅꒡ﻹ륖湵񀏸︩끯溛싕ﺃ񀃰溌ꛤ澍괁湄渪㪱湾轵ￏ붫洍㯣９䚊澢゜ﹽ꤭澱熴漄񀂑﹞澠聛溟㐪洣曢ﾑ컙ﻖ扢ﺯꃞﻯｻ靏﹠왧澝狜洫몈潑轗ﾢ񃥁ﴱ旒ﻥ码溆񃞄ﹽ񀀘숡漄똞渁愓涢񁮡澒뒚漀案澱뎜濌形潀囫﹈뗐濖񀥥潪񁀫滕䗀潋潔񃼟ﾴ渝濘񀓈澁澰񂢝ﾒ러ﾼ潳뾨ｙ烌ﻝ龜ｎ觛ﻘ񀬄񀂆ﾫﺬ｟滴贊湶񂝍ﾍ񀕝ￗ淬񀁭괞Ｗ񀥿漄񂜙滦溗啟ｈ񂯲񀀄񂇡湿䜘ﺑ쏱灂񃑟瀃쒸溛䀍ﺱ듁ﺨ漂񀛮潽񃤰濼ｨ漀溶쎎񀀉徴ｑ䥽湀蘖泦솗漇㧕︕뽤濱똛漀鬑潀񀋡１儼満񁣕澆颱瀵񀆔瀙諫񀀂졸ﾉ񁶬￙컧：鋺溻񃑪︯渁潕񀀦鴥滭肰渢忢ﷃ年︀񂴦澘玲澿靍滭񂹻￱䄺ﾫ淩￩뽆澷񂞀漿浃湿泘ﺫ普Ｃ㎵ﾘ񂽌滗騝潂淀＂񀗶潹񀄮ﺟ񃹼ﺖ벓漃񂅳溱񂒺Ｙ񀈚漷ꕾ漌쪡漸ﻫ㐇湚񂠧ﾭ瘁澮蒼渗꼞浊񂲞溁頞漨񃭄渁鮎񀀎䨵涵񀣸湄񂊖ￒ񂜒淌񁖛濋񀇖滿垥澝񃃷＼꜎漠籥漝﷊澁ﾃ񂈻溳񃀅񀀑秼︗㫅潠앢﷈ﻗ紙񀀑輠溏񃝵澊둤滄쩄滱喺ｱ񁗖񀁒윂ﻙꨁ澫񂍶Ｕ昪ﴸꍿｂ聾湪񂅸澪鏔（瞾溅庪漽筎潇剅Ｑ雍￩䯖漛蟹￭颕漊밫滖刺︟񁸄񀀾䰹潓꣄滞񃜛｜溏紀滌䫂澳뭣潀珳ﹾ鶕氺付澮񀒱潥矼潦놭澩蔟濉񀢡漠񀪼涽㊾漝񀐫ﺯ躂滐񂹇／㦎ｰ䲾ｎ찾ﻝ񃝴澟琥溘");

use std::arch::x86_64::*;
use std::mem::transmute;
use std::mem::transmute_copy;
const RELU: __m256 = unsafe { transmute([0f32; 8]) };

#[inline]
#[target_feature(enable = "avx2")]
unsafe fn sum_256(v: __m256) -> f32 {
    let mut sum = 0f32;
    let v: [f32; 8] = transmute(v);
    for i in 0..10 {
        sum += v.get_unchecked(i);
    }
    sum
}

#[derive(Clone, Copy, Debug)]
struct T10(__m256, __m256);
impl T10 {
    const fn from_data(data: [f32; 10]) -> Self {
        unsafe {
            let mut buf: [f32; 16] = transmute([0f32; 16]);
            let mut i = 0;
            while i < 10 {
                buf[i] = data[i];
                i += 1;
            }
            transmute(buf)
        }
    }
    const fn load(data: &[f32], offset: usize) -> Self {
        unsafe {
            let mut buf: [f32; 16] = transmute([0f32; 16]);
            let mut i = 0;
            while i < 10 {
                buf[i] = data[offset + i];
                i += 1;
            }
            transmute(buf)
        }
    }
    const fn loads(data: &[f32], offset: usize) -> [Self; 10] {
        unsafe {
            let mut buf: [Self; 10] = transmute([0f32; 160]);
            let mut i = 0;
            while i < 10 {
                buf[i] = Self::load(data, offset + i * 10);
                i += 1;
            }
            buf
        }
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn sum(&self) -> f32 {
        let v: [f32; 16] = transmute(*self);
        let mut sum = 0f32;
        for i in 0..10 {
            sum += v.get_unchecked(i);
        }
        sum
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn add(&self, other: &Self) -> Self {
        T10(
            _mm256_add_ps(self.0, other.0),
            _mm256_add_ps(self.1, other.1),
        )
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn mul(&self, other: &Self) -> Self {
        T10(
            _mm256_mul_ps(self.0, other.0),
            _mm256_mul_ps(self.1, other.1),
        )
    }
    #[inline]
    #[target_feature(enable = "avx2")]
    unsafe fn relu(&self) -> Self {
        T10(_mm256_max_ps(self.0, RELU), _mm256_max_ps(self.1, RELU))
    }
}

const fn pattern_table(p: [u32; 10]) -> T10 {
    unsafe {
        let mut i = 0;
        let mut buf = [0u32; 16];
        while i < 10 {
            let h = match p[i] {
                0 => transmute(0f32),
                1 => transmute(1f32),
                2 => transmute(-1f32),
                _ => transmute(0f32),
            };
            buf[i] = h;
            i += 1;
        }
        transmute(buf)
    }
}

const fn pattern() -> [T10; 59049] {
    let mut table: [T10; 59049] = unsafe { transmute([[0f32; 16]; 59049]) };
    let mut now = [0u32; 10];
    let mut next = 0;
    let mut val = 0;
    let mut i = 0;
    while i < 59049 {
        table[i] = pattern_table(now);
        if val < 2 {
            val += 1;
            now[next] = val;
        } else {
            next += 1;
            let mut j = 0;
            while j < next {
                now[j] = 0;
                j += 1;
            }
            while next < 9 && now[next] == 2 {
                now[next] = 0;
                next += 1;
            }
            now[next] += 1;
            next = 0;
            val = 0;
        }
        i += 1;
    }
    table
}

const PATTERN_TABLE: [T10; 59049] = pattern();

#[derive(Debug)]
struct Model10 {
    w1: [T10; 10],
    b1: T10,
    w2: [T10; 10],
    b2: T10,
    w3: T10,
    b3: f32,
}

impl Model10 {
    const fn load(data: &[f32], offset: usize) -> Self {
        Self {
            w1: T10::loads(data, 0 + offset),
            b1: T10::load(data, 100 + offset),
            w2: T10::loads(data, 110 + offset),
            b2: T10::load(data, 210 + offset),
            w3: T10::load(data, 220 + offset),
            b3: data[230 + offset],
        }
    }
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, mut input: T10) -> f32 {
        let mut out_put: [f32; 16] = [0f32; 16];
        for i in 0..10 {
            *out_put.get_unchecked_mut(i) = self.w1.get_unchecked(i).mul(&input).sum();
        }
        input = transmute::<_, T10>(out_put).add(&self.b1).relu();
        for i in 0..10 {
            *out_put.get_unchecked_mut(i) = self.w2.get_unchecked(i).mul(&input).sum();
        }
        input = transmute::<_, T10>(out_put).add(&self.b2).relu();
        input.mul(&self.w3).sum() + self.b3
    }
}

#[derive(Debug)]
struct Model8 {
    w1: [__m256; 8],
    b1: __m256,
    w2: [__m256; 8],
    b2: __m256,
    w3: __m256,
    b3: f32,
}

impl Model8 {
    fn load(stream: &[f32], offset: usize) -> Self {
        unsafe {
            let data: [__m256; 19] = transmute_copy(&stream[offset..]);
            Self {
                w1: transmute_copy(&data),
                b1: data[8],
                w2: transmute_copy(),
                b2: data[17],
                w3: data[18],
                b3: stream[offset + 152],
            }
        }
    }
    #[target_feature(enable = "avx2")]
    unsafe fn calc(&self, mut input: __m256) -> f32 {
        let mut out_put: [f32; 8] = [0f32; 8];
        for i in 0..8 {
            *out_put.get_unchecked_mut(i) =
                sum_256(_mm256_mul_ps(*self.w1.get_unchecked(i), input));
        }
        input = _mm256_max_ps(
            _mm256_add_ps(transmute::<_, __m256>(out_put), self.b1),
            RELU,
        );
        for i in 0..8 {
            *out_put.get_unchecked_mut(i) =
                sum_256(_mm256_mul_ps(*self.w2.get_unchecked(i), input));
        }
        input = _mm256_max_ps(
            _mm256_add_ps(transmute::<_, __m256>(out_put), self.b2),
            RELU,
        );
        sum_256(_mm256_mul_ps(self.w3, input)) + self.b3
    }
}

const EDGE: Model10 = Model10::load(&TESTDATA, 0);

pub fn temp() {
    let test = T10::from_data([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8f32, 9f32]);
    eprintln!("{:?}", test);
    unsafe {
        let s = EDGE.calc(test);
        eprintln!("{}", s);

        for i in 0..10 {
            let start = std::time::Instant::now();
            let mut sum = 0f32;
            for p in PATTERN_TABLE.iter() {
                sum += EDGE.calc(*p);
            }
            eprintln!("{:?}", start.elapsed());
            eprintln!("{}", sum);
        }

        let b = transmute::<u32, f32>(transmute::<_, u32>(10.0f32) & transmute::<_, u32>(-10.0f32));
        assert_eq!(10.0f32, b);
        let start = std::time::Instant::now();
        let model = Model8::load(&TESTDATA, 231 * 2);
        eprintln!("{:?}", start.elapsed());
        let data: __m256 = transmute([0f32; 8]);
        let res = model.calc(data);
        eprintln!("{}", res);
    }
}
